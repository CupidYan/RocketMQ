<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultMQPushConsumerImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rocketmq-client 4.1.0-incubating-SNAPSHOT</a> &gt; <a href="index.source.html" class="el_package">org.apache.rocketmq.client.impl.consumer</a> &gt; <span class="el_source">DefaultMQPushConsumerImpl.java</span></div><h1>DefaultMQPushConsumerImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.rocketmq.client.impl.consumer;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import org.apache.rocketmq.client.QueryResult;
import org.apache.rocketmq.client.Validators;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.PullCallback;
import org.apache.rocketmq.client.consumer.PullResult;
import org.apache.rocketmq.client.consumer.listener.MessageListener;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;
import org.apache.rocketmq.client.consumer.store.LocalFileOffsetStore;
import org.apache.rocketmq.client.consumer.store.OffsetStore;
import org.apache.rocketmq.client.consumer.store.ReadOffsetType;
import org.apache.rocketmq.client.consumer.store.RemoteBrokerOffsetStore;
import org.apache.rocketmq.client.exception.MQBrokerException;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.hook.ConsumeMessageContext;
import org.apache.rocketmq.client.hook.ConsumeMessageHook;
import org.apache.rocketmq.client.hook.FilterMessageHook;
import org.apache.rocketmq.client.impl.CommunicationMode;
import org.apache.rocketmq.client.impl.MQClientManager;
import org.apache.rocketmq.client.impl.factory.MQClientInstance;
import org.apache.rocketmq.client.log.ClientLogger;
import org.apache.rocketmq.client.stat.ConsumerStatsManager;
import org.apache.rocketmq.common.MixAll;
import org.apache.rocketmq.common.ServiceState;
import org.apache.rocketmq.common.UtilAll;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.filter.FilterAPI;
import org.apache.rocketmq.common.help.FAQUrl;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.common.message.MessageAccessor;
import org.apache.rocketmq.common.message.MessageConst;
import org.apache.rocketmq.common.message.MessageExt;
import org.apache.rocketmq.common.message.MessageQueue;
import org.apache.rocketmq.common.protocol.body.ConsumeStatus;
import org.apache.rocketmq.common.protocol.body.ConsumerRunningInfo;
import org.apache.rocketmq.common.protocol.body.ProcessQueueInfo;
import org.apache.rocketmq.common.protocol.body.QueueTimeSpan;
import org.apache.rocketmq.common.protocol.heartbeat.ConsumeType;
import org.apache.rocketmq.common.protocol.heartbeat.MessageModel;
import org.apache.rocketmq.common.protocol.heartbeat.SubscriptionData;
import org.apache.rocketmq.common.protocol.route.BrokerData;
import org.apache.rocketmq.common.protocol.route.TopicRouteData;
import org.apache.rocketmq.common.sysflag.PullSysFlag;
import org.apache.rocketmq.remoting.RPCHook;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.apache.rocketmq.remoting.exception.RemotingException;
import org.slf4j.Logger;

public class DefaultMQPushConsumerImpl implements MQConsumerInner {
    /**
     * Delay some time when exception occur
     */
    private static final long PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION = 3000;
    /**
     * Flow control interval
     */
    private static final long PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL = 50;
    /**
     * Delay some time when suspend pull service
     */
    private static final long PULL_TIME_DELAY_MILLS_WHEN_SUSPEND = 1000;
    private static final long BROKER_SUSPEND_MAX_TIME_MILLIS = 1000 * 15;
    private static final long CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND = 1000 * 30;
<span class="fc" id="L93">    private final Logger log = ClientLogger.getLog();</span>
    private final DefaultMQPushConsumer defaultMQPushConsumer;
<span class="fc" id="L95">    private final RebalanceImpl rebalanceImpl = new RebalancePushImpl(this);</span>
<span class="fc" id="L96">    private final ArrayList&lt;FilterMessageHook&gt; filterMessageHookList = new ArrayList&lt;FilterMessageHook&gt;();</span>
<span class="fc" id="L97">    private final long consumerStartTimestamp = System.currentTimeMillis();</span>
<span class="fc" id="L98">    private final ArrayList&lt;ConsumeMessageHook&gt; consumeMessageHookList = new ArrayList&lt;ConsumeMessageHook&gt;();</span>
    private final RPCHook rpcHook;
<span class="fc" id="L100">    private ServiceState serviceState = ServiceState.CREATE_JUST;</span>
    private MQClientInstance mQClientFactory;
    private PullAPIWrapper pullAPIWrapper;
<span class="fc" id="L103">    private volatile boolean pause = false;</span>
<span class="fc" id="L104">    private boolean consumeOrderly = false;</span>
    private MessageListener messageListenerInner;
    private OffsetStore offsetStore;
    private ConsumeMessageService consumeMessageService;
<span class="fc" id="L108">    private long flowControlTimes1 = 0;</span>
<span class="fc" id="L109">    private long flowControlTimes2 = 0;</span>

<span class="fc" id="L111">    public DefaultMQPushConsumerImpl(DefaultMQPushConsumer defaultMQPushConsumer, RPCHook rpcHook) {</span>
<span class="fc" id="L112">        this.defaultMQPushConsumer = defaultMQPushConsumer;</span>
<span class="fc" id="L113">        this.rpcHook = rpcHook;</span>
<span class="fc" id="L114">    }</span>

    public void registerFilterMessageHook(final FilterMessageHook hook) {
<span class="nc" id="L117">        this.filterMessageHookList.add(hook);</span>
<span class="nc" id="L118">        log.info(&quot;register FilterMessageHook Hook, {}&quot;, hook.hookName());</span>
<span class="nc" id="L119">    }</span>

    public boolean hasHook() {
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">        return !this.consumeMessageHookList.isEmpty();</span>
    }

    public void registerConsumeMessageHook(final ConsumeMessageHook hook) {
<span class="nc" id="L126">        this.consumeMessageHookList.add(hook);</span>
<span class="nc" id="L127">        log.info(&quot;register consumeMessageHook Hook, {}&quot;, hook.hookName());</span>
<span class="nc" id="L128">    }</span>

    public void executeHookBefore(final ConsumeMessageContext context) {
<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (!this.consumeMessageHookList.isEmpty()) {</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">            for (ConsumeMessageHook hook : this.consumeMessageHookList) {</span>
                try {
<span class="nc" id="L134">                    hook.consumeMessageBefore(context);</span>
<span class="nc" id="L135">                } catch (Throwable e) {</span>
<span class="nc" id="L136">                }</span>
<span class="nc" id="L137">            }</span>
        }
<span class="nc" id="L139">    }</span>

    public void executeHookAfter(final ConsumeMessageContext context) {
<span class="nc bnc" id="L142" title="All 2 branches missed.">        if (!this.consumeMessageHookList.isEmpty()) {</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">            for (ConsumeMessageHook hook : this.consumeMessageHookList) {</span>
                try {
<span class="nc" id="L145">                    hook.consumeMessageAfter(context);</span>
<span class="nc" id="L146">                } catch (Throwable e) {</span>
<span class="nc" id="L147">                }</span>
<span class="nc" id="L148">            }</span>
        }
<span class="nc" id="L150">    }</span>

    public void createTopic(String key, String newTopic, int queueNum) throws MQClientException {
<span class="nc" id="L153">        createTopic(key, newTopic, queueNum, 0);</span>
<span class="nc" id="L154">    }</span>

    public void createTopic(String key, String newTopic, int queueNum, int topicSysFlag) throws MQClientException {
<span class="nc" id="L157">        this.mQClientFactory.getMQAdminImpl().createTopic(key, newTopic, queueNum, topicSysFlag);</span>
<span class="nc" id="L158">    }</span>

    public Set&lt;MessageQueue&gt; fetchSubscribeMessageQueues(String topic) throws MQClientException {
<span class="nc" id="L161">        Set&lt;MessageQueue&gt; result = this.rebalanceImpl.getTopicSubscribeInfoTable().get(topic);</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        if (null == result) {</span>
<span class="nc" id="L163">            this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span>
<span class="nc" id="L164">            result = this.rebalanceImpl.getTopicSubscribeInfoTable().get(topic);</span>
        }

<span class="nc bnc" id="L167" title="All 2 branches missed.">        if (null == result) {</span>
<span class="nc" id="L168">            throw new MQClientException(&quot;The topic[&quot; + topic + &quot;] not exist&quot;, null);</span>
        }

<span class="nc" id="L171">        return result;</span>
    }

    public DefaultMQPushConsumer getDefaultMQPushConsumer() {
<span class="fc" id="L175">        return defaultMQPushConsumer;</span>
    }

    public long earliestMsgStoreTime(MessageQueue mq) throws MQClientException {
<span class="nc" id="L179">        return this.mQClientFactory.getMQAdminImpl().earliestMsgStoreTime(mq);</span>
    }

    public long maxOffset(MessageQueue mq) throws MQClientException {
<span class="nc" id="L183">        return this.mQClientFactory.getMQAdminImpl().maxOffset(mq);</span>
    }

    public long minOffset(MessageQueue mq) throws MQClientException {
<span class="nc" id="L187">        return this.mQClientFactory.getMQAdminImpl().minOffset(mq);</span>
    }

    public OffsetStore getOffsetStore() {
<span class="fc" id="L191">        return offsetStore;</span>
    }

    public void setOffsetStore(OffsetStore offsetStore) {
<span class="nc" id="L195">        this.offsetStore = offsetStore;</span>
<span class="nc" id="L196">    }</span>

    public void pullMessage(final PullRequest pullRequest) {
<span class="fc" id="L199">        final ProcessQueue processQueue = pullRequest.getProcessQueue();</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        if (processQueue.isDropped()) {</span>
<span class="nc" id="L201">            log.info(&quot;the pull request[{}] is dropped.&quot;, pullRequest.toString());</span>
<span class="nc" id="L202">            return;</span>
        }

<span class="fc" id="L205">        pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());</span>

        try {
<span class="fc" id="L208">            this.makeSureStateOK();</span>
<span class="nc" id="L209">        } catch (MQClientException e) {</span>
<span class="nc" id="L210">            log.warn(&quot;pullMessage exception, consumer state not ok&quot;, e);</span>
<span class="nc" id="L211">            this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span>
<span class="nc" id="L212">            return;</span>
<span class="fc" id="L213">        }</span>

<span class="pc bpc" id="L215" title="1 of 2 branches missed.">        if (this.isPause()) {</span>
<span class="nc" id="L216">            log.warn(&quot;consumer was paused, execute pull request later. instanceName={}, group={}&quot;, this.defaultMQPushConsumer.getInstanceName(), this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L217">            this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);</span>
<span class="nc" id="L218">            return;</span>
        }

<span class="fc" id="L221">        long size = processQueue.getMsgCount().get();</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">        if (size &gt; this.defaultMQPushConsumer.getPullThresholdForQueue()) {</span>
<span class="nc" id="L223">            this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">            if ((flowControlTimes1++ % 1000) == 0) {</span>
<span class="nc" id="L225">                log.warn(</span>
                    &quot;the consumer message buffer is full, so do flow control, minOffset={}, maxOffset={}, size={}, pullRequest={}, flowControlTimes={}&quot;,
<span class="nc" id="L227">                    processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), size, pullRequest, flowControlTimes1);</span>
            }
<span class="nc" id="L229">            return;</span>
        }

<span class="fc bfc" id="L232" title="All 2 branches covered.">        if (!this.consumeOrderly) {</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">            if (processQueue.getMaxSpan() &gt; this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) {</span>
<span class="nc" id="L234">                this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">                if ((flowControlTimes2++ % 1000) == 0) {</span>
<span class="nc" id="L236">                    log.warn(</span>
                        &quot;the queue's messages, span too long, so do flow control, minOffset={}, maxOffset={}, maxSpan={}, pullRequest={}, flowControlTimes={}&quot;,
<span class="nc" id="L238">                        processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(),</span>
<span class="nc" id="L239">                        pullRequest, flowControlTimes2);</span>
                }
<span class="nc" id="L241">                return;</span>
            }
        } else {
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">            if (processQueue.isLocked()) {</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">                if (!pullRequest.isLockedFirst()) {</span>
<span class="fc" id="L246">                    final long offset = this.rebalanceImpl.computePullFromWhere(pullRequest.getMessageQueue());</span>
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">                    boolean brokerBusy = offset &lt; pullRequest.getNextOffset();</span>
<span class="fc" id="L248">                    log.info(&quot;the first time to pull message, so fix offset from broker. pullRequest: {} NewOffset: {} brokerBusy: {}&quot;,</span>
<span class="fc" id="L249">                        pullRequest, offset, brokerBusy);</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">                    if (brokerBusy) {</span>
<span class="fc" id="L251">                        log.info(&quot;[NOTIFYME]the first time to pull message, but pull request offset larger than broker consume offset. pullRequest: {} NewOffset: {}&quot;,</span>
<span class="fc" id="L252">                            pullRequest, offset);</span>
                    }

<span class="fc" id="L255">                    pullRequest.setLockedFirst(true);</span>
<span class="fc" id="L256">                    pullRequest.setNextOffset(offset);</span>
<span class="fc" id="L257">                }</span>
            } else {
<span class="nc" id="L259">                this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span>
<span class="nc" id="L260">                log.info(&quot;pull message later because not locked in broker, {}&quot;, pullRequest);</span>
<span class="nc" id="L261">                return;</span>
            }
        }

<span class="fc" id="L265">        final SubscriptionData subscriptionData = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">        if (null == subscriptionData) {</span>
<span class="nc" id="L267">            this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span>
<span class="nc" id="L268">            log.warn(&quot;find the consumer's subscription failed, {}&quot;, pullRequest);</span>
<span class="nc" id="L269">            return;</span>
        }

<span class="fc" id="L272">        final long beginTimestamp = System.currentTimeMillis();</span>

<span class="fc" id="L274">        PullCallback pullCallback = new PullCallback() {</span>
            @Override
            public void onSuccess(PullResult pullResult) {
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">                if (pullResult != null) {</span>
<span class="fc" id="L278">                    pullResult = DefaultMQPushConsumerImpl.this.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,</span>
                        subscriptionData);

<span class="pc bpc" id="L281" title="4 of 5 branches missed.">                    switch (pullResult.getPullStatus()) {</span>
                        case FOUND:
<span class="fc" id="L283">                            long prevRequestOffset = pullRequest.getNextOffset();</span>
<span class="fc" id="L284">                            pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span>
<span class="fc" id="L285">                            long pullRT = System.currentTimeMillis() - beginTimestamp;</span>
<span class="fc" id="L286">                            DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),</span>
<span class="fc" id="L287">                                pullRequest.getMessageQueue().getTopic(), pullRT);</span>

<span class="fc" id="L289">                            long firstMsgOffset = Long.MAX_VALUE;</span>
<span class="pc bpc" id="L290" title="2 of 4 branches missed.">                            if (pullResult.getMsgFoundList() == null || pullResult.getMsgFoundList().isEmpty()) {</span>
<span class="nc" id="L291">                                DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);</span>
                            } else {
<span class="fc" id="L293">                                firstMsgOffset = pullResult.getMsgFoundList().get(0).getQueueOffset();</span>

<span class="fc" id="L295">                                DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),</span>
<span class="fc" id="L296">                                    pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());</span>

<span class="fc" id="L298">                                boolean dispathToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</span>
<span class="fc" id="L299">                                DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest(//</span>
<span class="fc" id="L300">                                    pullResult.getMsgFoundList(), //</span>
                                    processQueue, //
<span class="fc" id="L302">                                    pullRequest.getMessageQueue(), //</span>
                                    dispathToConsume);

<span class="pc bpc" id="L305" title="1 of 2 branches missed.">                                if (DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval() &gt; 0) {</span>
<span class="fc" id="L306">                                    DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest,</span>
<span class="fc" id="L307">                                        DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval());</span>
                                } else {
<span class="nc" id="L309">                                    DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);</span>
                                }
                            }

<span class="pc bpc" id="L313" title="2 of 4 branches missed.">                            if (pullResult.getNextBeginOffset() &lt; prevRequestOffset//</span>
                                || firstMsgOffset &lt; prevRequestOffset) {
<span class="fc" id="L315">                                log.warn(</span>
                                    &quot;[BUG] pull message result maybe data wrong, nextBeginOffset: {} firstMsgOffset: {} prevRequestOffset: {}&quot;, //
<span class="fc" id="L317">                                    pullResult.getNextBeginOffset(), //</span>
<span class="fc" id="L318">                                    firstMsgOffset, //</span>
<span class="fc" id="L319">                                    prevRequestOffset);</span>
                            }

                            break;
                        case NO_NEW_MSG:
<span class="nc" id="L324">                            pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span>

<span class="nc" id="L326">                            DefaultMQPushConsumerImpl.this.correctTagsOffset(pullRequest);</span>

<span class="nc" id="L328">                            DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);</span>
<span class="nc" id="L329">                            break;</span>
                        case NO_MATCHED_MSG:
<span class="nc" id="L331">                            pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span>

<span class="nc" id="L333">                            DefaultMQPushConsumerImpl.this.correctTagsOffset(pullRequest);</span>

<span class="nc" id="L335">                            DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);</span>
<span class="nc" id="L336">                            break;</span>
                        case OFFSET_ILLEGAL:
<span class="nc" id="L338">                            log.warn(&quot;the pull request offset illegal, {} {}&quot;, //</span>
<span class="nc" id="L339">                                pullRequest.toString(), pullResult.toString());</span>
<span class="nc" id="L340">                            pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span>

<span class="nc" id="L342">                            pullRequest.getProcessQueue().setDropped(true);</span>
<span class="nc" id="L343">                            DefaultMQPushConsumerImpl.this.executeTaskLater(new Runnable() {</span>

                                @Override
                                public void run() {
                                    try {
<span class="nc" id="L348">                                        DefaultMQPushConsumerImpl.this.offsetStore.updateOffset(pullRequest.getMessageQueue(),</span>
<span class="nc" id="L349">                                            pullRequest.getNextOffset(), false);</span>

<span class="nc" id="L351">                                        DefaultMQPushConsumerImpl.this.offsetStore.persist(pullRequest.getMessageQueue());</span>

<span class="nc" id="L353">                                        DefaultMQPushConsumerImpl.this.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue());</span>

<span class="nc" id="L355">                                        log.warn(&quot;fix the pull request offset, {}&quot;, pullRequest);</span>
<span class="nc" id="L356">                                    } catch (Throwable e) {</span>
<span class="nc" id="L357">                                        log.error(&quot;executeTaskLater Exception&quot;, e);</span>
<span class="nc" id="L358">                                    }</span>
<span class="nc" id="L359">                                }</span>
                            }, 10000);
<span class="nc" id="L361">                            break;</span>
                        default:
                            break;
                    }
                }
<span class="fc" id="L366">            }</span>

            @Override
            public void onException(Throwable e) {
<span class="nc bnc" id="L370" title="All 2 branches missed.">                if (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {</span>
<span class="nc" id="L371">                    log.warn(&quot;execute the pull request exception&quot;, e);</span>
                }

<span class="nc" id="L374">                DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span>
<span class="nc" id="L375">            }</span>
        };

<span class="fc" id="L378">        boolean commitOffsetEnable = false;</span>
<span class="fc" id="L379">        long commitOffsetValue = 0L;</span>
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">        if (MessageModel.CLUSTERING == this.defaultMQPushConsumer.getMessageModel()) {</span>
<span class="fc" id="L381">            commitOffsetValue = this.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY);</span>
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">            if (commitOffsetValue &gt; 0) {</span>
<span class="nc" id="L383">                commitOffsetEnable = true;</span>
            }
        }

<span class="fc" id="L387">        String subExpression = null;</span>
<span class="fc" id="L388">        boolean classFilter = false;</span>
<span class="fc" id="L389">        SubscriptionData sd = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span>
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">        if (sd != null) {</span>
<span class="pc bpc" id="L391" title="3 of 4 branches missed.">            if (this.defaultMQPushConsumer.isPostSubscriptionWhenPull() &amp;&amp; !sd.isClassFilterMode()) {</span>
<span class="nc" id="L392">                subExpression = sd.getSubString();</span>
            }

<span class="fc" id="L395">            classFilter = sd.isClassFilterMode();</span>
        }

<span class="pc bpc" id="L398" title="1 of 2 branches missed.">        int sysFlag = PullSysFlag.buildSysFlag(//</span>
            commitOffsetEnable, // commitOffset
            true, // suspend
            subExpression != null, // subscription
            classFilter // class filter
        );
        try {
<span class="fc" id="L405">            this.pullAPIWrapper.pullKernelImpl(//</span>
<span class="fc" id="L406">                pullRequest.getMessageQueue(), // 1</span>
                subExpression, // 2
<span class="fc" id="L408">                subscriptionData.getSubVersion(), // 3</span>
<span class="fc" id="L409">                pullRequest.getNextOffset(), // 4</span>
<span class="fc" id="L410">                this.defaultMQPushConsumer.getPullBatchSize(), // 5</span>
                sysFlag, // 6
                commitOffsetValue, // 7
                BROKER_SUSPEND_MAX_TIME_MILLIS, // 8
                CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND, // 9
                CommunicationMode.ASYNC, // 10
                pullCallback// 11
            );
<span class="nc" id="L418">        } catch (Exception e) {</span>
<span class="nc" id="L419">            log.error(&quot;pullKernelImpl exception&quot;, e);</span>
<span class="nc" id="L420">            this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span>
<span class="fc" id="L421">        }</span>
<span class="fc" id="L422">    }</span>

    private void makeSureStateOK() throws MQClientException {
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">        if (this.serviceState != ServiceState.RUNNING) {</span>
<span class="nc" id="L426">            throw new MQClientException(&quot;The consumer service state not OK, &quot;//</span>
                + this.serviceState//
<span class="nc" id="L428">                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span>
                null);
        }
<span class="fc" id="L431">    }</span>

    private void executePullRequestLater(final PullRequest pullRequest, final long timeDelay) {
<span class="fc" id="L434">        this.mQClientFactory.getPullMessageService().executePullRequestLater(pullRequest, timeDelay);</span>
<span class="fc" id="L435">    }</span>

    public boolean isPause() {
<span class="fc" id="L438">        return pause;</span>
    }

    public void setPause(boolean pause) {
<span class="nc" id="L442">        this.pause = pause;</span>
<span class="nc" id="L443">    }</span>

    public ConsumerStatsManager getConsumerStatsManager() {
<span class="fc" id="L446">        return this.mQClientFactory.getConsumerStatsManager();</span>
    }

    public void executePullRequestImmediately(final PullRequest pullRequest) {
<span class="fc" id="L450">        this.mQClientFactory.getPullMessageService().executePullRequestImmediately(pullRequest);</span>
<span class="fc" id="L451">    }</span>

    private void correctTagsOffset(final PullRequest pullRequest) {
<span class="nc bnc" id="L454" title="All 2 branches missed.">        if (0L == pullRequest.getProcessQueue().getMsgCount().get()) {</span>
<span class="nc" id="L455">            this.offsetStore.updateOffset(pullRequest.getMessageQueue(), pullRequest.getNextOffset(), true);</span>
        }
<span class="nc" id="L457">    }</span>

    public void executeTaskLater(final Runnable r, final long timeDelay) {
<span class="nc" id="L460">        this.mQClientFactory.getPullMessageService().executeTaskLater(r, timeDelay);</span>
<span class="nc" id="L461">    }</span>

    public QueryResult queryMessage(String topic, String key, int maxNum, long begin, long end)
        throws MQClientException, InterruptedException {
<span class="nc" id="L465">        return this.mQClientFactory.getMQAdminImpl().queryMessage(topic, key, maxNum, begin, end);</span>
    }

    public MessageExt queryMessageByUniqKey(String topic, String uniqKey) throws MQClientException,
        InterruptedException {
<span class="nc" id="L470">        return this.mQClientFactory.getMQAdminImpl().queryMessageByUniqKey(topic, uniqKey);</span>
    }

    public void registerMessageListener(MessageListener messageListener) {
<span class="fc" id="L474">        this.messageListenerInner = messageListener;</span>
<span class="fc" id="L475">    }</span>

    public void resume() {
<span class="nc" id="L478">        this.pause = false;</span>
<span class="nc" id="L479">        doRebalance();</span>
<span class="nc" id="L480">        log.info(&quot;resume this consumer, {}&quot;, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L481">    }</span>

    public void sendMessageBack(MessageExt msg, int delayLevel, final String brokerName)
        throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
        try {
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">            String brokerAddr = (null != brokerName) ? this.mQClientFactory.findBrokerAddressInPublish(brokerName)</span>
<span class="pc" id="L487">                : RemotingHelper.parseSocketAddressAddr(msg.getStoreHost());</span>
<span class="fc" id="L488">            this.mQClientFactory.getMQClientAPIImpl().consumerSendMessageBack(brokerAddr, msg,</span>
<span class="fc" id="L489">                this.defaultMQPushConsumer.getConsumerGroup(), delayLevel, 5000, getMaxReconsumeTimes());</span>
<span class="nc" id="L490">        } catch (Exception e) {</span>
<span class="nc" id="L491">            log.error(&quot;sendMessageBack Exception, &quot; + this.defaultMQPushConsumer.getConsumerGroup(), e);</span>

<span class="nc" id="L493">            Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());</span>

<span class="nc" id="L495">            String originMsgId = MessageAccessor.getOriginMessageId(msg);</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">            MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);</span>

<span class="nc" id="L498">            newMsg.setFlag(msg.getFlag());</span>
<span class="nc" id="L499">            MessageAccessor.setProperties(newMsg, msg.getProperties());</span>
<span class="nc" id="L500">            MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());</span>
<span class="nc" id="L501">            MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes() + 1));</span>
<span class="nc" id="L502">            MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));</span>
<span class="nc" id="L503">            newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes());</span>

<span class="nc" id="L505">            this.mQClientFactory.getDefaultMQProducer().send(newMsg);</span>
<span class="fc" id="L506">        }</span>
<span class="fc" id="L507">    }</span>

    private int getMaxReconsumeTimes() {
        // default reconsume times: 16
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">        if (this.defaultMQPushConsumer.getMaxReconsumeTimes() == -1) {</span>
<span class="fc" id="L512">            return 16;</span>
        } else {
<span class="nc" id="L514">            return this.defaultMQPushConsumer.getMaxReconsumeTimes();</span>
        }
    }

    public void shutdown() {
<span class="pc bpc" id="L519" title="3 of 4 branches missed.">        switch (this.serviceState) {</span>
            case CREATE_JUST:
<span class="nc" id="L521">                break;</span>
            case RUNNING:
<span class="fc" id="L523">                this.consumeMessageService.shutdown();</span>
<span class="fc" id="L524">                this.persistConsumerOffset();</span>
<span class="fc" id="L525">                this.mQClientFactory.unregisterConsumer(this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="fc" id="L526">                this.mQClientFactory.shutdown();</span>
<span class="fc" id="L527">                log.info(&quot;the consumer [{}] shutdown OK&quot;, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="fc" id="L528">                this.rebalanceImpl.destroy();</span>
<span class="fc" id="L529">                this.serviceState = ServiceState.SHUTDOWN_ALREADY;</span>
<span class="fc" id="L530">                break;</span>
            case SHUTDOWN_ALREADY:
<span class="nc" id="L532">                break;</span>
            default:
                break;
        }
<span class="fc" id="L536">    }</span>

    public void start() throws MQClientException {
<span class="pc bpc" id="L539" title="2 of 3 branches missed.">        switch (this.serviceState) {</span>
            case CREATE_JUST:
<span class="fc" id="L541">                log.info(&quot;the consumer [{}] start beginning. messageModel={}, isUnitMode={}&quot;, this.defaultMQPushConsumer.getConsumerGroup(),</span>
<span class="fc" id="L542">                    this.defaultMQPushConsumer.getMessageModel(), this.defaultMQPushConsumer.isUnitMode());</span>
<span class="fc" id="L543">                this.serviceState = ServiceState.START_FAILED;</span>

<span class="fc" id="L545">                this.checkConfig();</span>

<span class="fc" id="L547">                this.copySubscription();</span>

<span class="pc bpc" id="L549" title="1 of 2 branches missed.">                if (this.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) {</span>
<span class="fc" id="L550">                    this.defaultMQPushConsumer.changeInstanceNameToPID();</span>
                }

<span class="fc" id="L553">                this.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(this.defaultMQPushConsumer, this.rpcHook);</span>

<span class="fc" id="L555">                this.rebalanceImpl.setConsumerGroup(this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="fc" id="L556">                this.rebalanceImpl.setMessageModel(this.defaultMQPushConsumer.getMessageModel());</span>
<span class="fc" id="L557">                this.rebalanceImpl.setAllocateMessageQueueStrategy(this.defaultMQPushConsumer.getAllocateMessageQueueStrategy());</span>
<span class="fc" id="L558">                this.rebalanceImpl.setmQClientFactory(this.mQClientFactory);</span>

<span class="fc" id="L560">                this.pullAPIWrapper = new PullAPIWrapper(</span>
                    mQClientFactory,
<span class="fc" id="L562">                    this.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());</span>
<span class="fc" id="L563">                this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);</span>

<span class="pc bpc" id="L565" title="1 of 2 branches missed.">                if (this.defaultMQPushConsumer.getOffsetStore() != null) {</span>
<span class="nc" id="L566">                    this.offsetStore = this.defaultMQPushConsumer.getOffsetStore();</span>
                } else {
<span class="pc bpc" id="L568" title="2 of 3 branches missed.">                    switch (this.defaultMQPushConsumer.getMessageModel()) {</span>
                        case BROADCASTING:
<span class="nc" id="L570">                            this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L571">                            break;</span>
                        case CLUSTERING:
<span class="fc" id="L573">                            this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="fc" id="L574">                            break;</span>
                        default:
                            break;
                    }
                }
<span class="fc" id="L579">                this.offsetStore.load();</span>

<span class="pc bpc" id="L581" title="1 of 2 branches missed.">                if (this.getMessageListenerInner() instanceof MessageListenerOrderly) {</span>
<span class="nc" id="L582">                    this.consumeOrderly = true;</span>
<span class="nc" id="L583">                    this.consumeMessageService =</span>
<span class="nc" id="L584">                        new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner());</span>
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">                } else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) {</span>
<span class="fc" id="L586">                    this.consumeOrderly = false;</span>
<span class="fc" id="L587">                    this.consumeMessageService =</span>
<span class="fc" id="L588">                        new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner());</span>
                }

<span class="fc" id="L591">                this.consumeMessageService.start();</span>

<span class="fc" id="L593">                boolean registerOK = mQClientFactory.registerConsumer(this.defaultMQPushConsumer.getConsumerGroup(), this);</span>
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">                if (!registerOK) {</span>
<span class="nc" id="L595">                    this.serviceState = ServiceState.CREATE_JUST;</span>
<span class="nc" id="L596">                    this.consumeMessageService.shutdown();</span>
<span class="nc" id="L597">                    throw new MQClientException(&quot;The consumer group[&quot; + this.defaultMQPushConsumer.getConsumerGroup()</span>
<span class="nc" id="L598">                        + &quot;] has been created before, specify another name please.&quot; + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span>
                        null);
                }

<span class="fc" id="L602">                mQClientFactory.start();</span>
<span class="fc" id="L603">                log.info(&quot;the consumer [{}] start OK.&quot;, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="fc" id="L604">                this.serviceState = ServiceState.RUNNING;</span>
<span class="fc" id="L605">                break;</span>
            case RUNNING:
            case START_FAILED:
            case SHUTDOWN_ALREADY:
<span class="nc" id="L609">                throw new MQClientException(&quot;The PushConsumer service state not OK, maybe started once, &quot;//</span>
                    + this.serviceState//
<span class="nc" id="L611">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span>
                    null);
            default:
                break;
        }

<span class="fc" id="L617">        this.updateTopicSubscribeInfoWhenSubscriptionChanged();</span>

<span class="fc" id="L619">        this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span>

<span class="fc" id="L621">        this.mQClientFactory.rebalanceImmediately();</span>
<span class="fc" id="L622">    }</span>

    private void checkConfig() throws MQClientException {
<span class="fc" id="L625">        Validators.checkGroup(this.defaultMQPushConsumer.getConsumerGroup());</span>

<span class="pc bpc" id="L627" title="1 of 2 branches missed.">        if (null == this.defaultMQPushConsumer.getConsumerGroup()) {</span>
<span class="nc" id="L628">            throw new MQClientException(</span>
                &quot;consumerGroup is null&quot;
<span class="nc" id="L630">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="pc bpc" id="L634" title="1 of 2 branches missed.">        if (this.defaultMQPushConsumer.getConsumerGroup().equals(MixAll.DEFAULT_CONSUMER_GROUP)) {</span>
<span class="nc" id="L635">            throw new MQClientException(</span>
                &quot;consumerGroup can not equal &quot;
                    + MixAll.DEFAULT_CONSUMER_GROUP
                    + &quot;, please specify another one.&quot;
<span class="nc" id="L639">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="pc bpc" id="L643" title="1 of 2 branches missed.">        if (null == this.defaultMQPushConsumer.getMessageModel()) {</span>
<span class="nc" id="L644">            throw new MQClientException(</span>
                &quot;messageModel is null&quot;
<span class="nc" id="L646">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="pc bpc" id="L650" title="1 of 2 branches missed.">        if (null == this.defaultMQPushConsumer.getConsumeFromWhere()) {</span>
<span class="nc" id="L651">            throw new MQClientException(</span>
                &quot;consumeFromWhere is null&quot;
<span class="nc" id="L653">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="fc" id="L657">        Date dt = UtilAll.parseDate(this.defaultMQPushConsumer.getConsumeTimestamp(), UtilAll.YYYY_MMDD_HHMMSS);</span>
<span class="pc bpc" id="L658" title="1 of 2 branches missed.">        if (null == dt) {</span>
<span class="nc" id="L659">            throw new MQClientException(</span>
                &quot;consumeTimestamp is invalid, YYYY_MMDD_HHMMSS&quot;
<span class="nc" id="L661">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // allocateMessageQueueStrategy
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">        if (null == this.defaultMQPushConsumer.getAllocateMessageQueueStrategy()) {</span>
<span class="nc" id="L667">            throw new MQClientException(</span>
                &quot;allocateMessageQueueStrategy is null&quot;
<span class="nc" id="L669">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // subscription
<span class="pc bpc" id="L674" title="1 of 2 branches missed.">        if (null == this.defaultMQPushConsumer.getSubscription()) {</span>
<span class="nc" id="L675">            throw new MQClientException(</span>
                &quot;subscription is null&quot;
<span class="nc" id="L677">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // messageListener
<span class="pc bpc" id="L682" title="1 of 2 branches missed.">        if (null == this.defaultMQPushConsumer.getMessageListener()) {</span>
<span class="nc" id="L683">            throw new MQClientException(</span>
                &quot;messageListener is null&quot;
<span class="nc" id="L685">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="fc" id="L689">        boolean orderly = this.defaultMQPushConsumer.getMessageListener() instanceof MessageListenerOrderly;</span>
<span class="fc" id="L690">        boolean concurrently = this.defaultMQPushConsumer.getMessageListener() instanceof MessageListenerConcurrently;</span>
<span class="pc bpc" id="L691" title="2 of 4 branches missed.">        if (!orderly &amp;&amp; !concurrently) {</span>
<span class="nc" id="L692">            throw new MQClientException(</span>
                &quot;messageListener must be instanceof MessageListenerOrderly or MessageListenerConcurrently&quot;
<span class="nc" id="L694">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // consumeThreadMin
<span class="pc bpc" id="L699" title="1 of 2 branches missed.">        if (this.defaultMQPushConsumer.getConsumeThreadMin() &lt; 1</span>
<span class="pc bpc" id="L700" title="1 of 2 branches missed.">            || this.defaultMQPushConsumer.getConsumeThreadMin() &gt; 1000</span>
<span class="pc bpc" id="L701" title="1 of 2 branches missed.">            || this.defaultMQPushConsumer.getConsumeThreadMin() &gt; this.defaultMQPushConsumer.getConsumeThreadMax()) {</span>
<span class="nc" id="L702">            throw new MQClientException(</span>
                &quot;consumeThreadMin Out of range [1, 1000]&quot;
<span class="nc" id="L704">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // consumeThreadMax
<span class="pc bpc" id="L709" title="2 of 4 branches missed.">        if (this.defaultMQPushConsumer.getConsumeThreadMax() &lt; 1 || this.defaultMQPushConsumer.getConsumeThreadMax() &gt; 1000) {</span>
<span class="nc" id="L710">            throw new MQClientException(</span>
                &quot;consumeThreadMax Out of range [1, 1000]&quot;
<span class="nc" id="L712">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // consumeConcurrentlyMaxSpan
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">        if (this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan() &lt; 1</span>
<span class="pc bpc" id="L718" title="1 of 2 branches missed.">            || this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan() &gt; 65535) {</span>
<span class="nc" id="L719">            throw new MQClientException(</span>
                &quot;consumeConcurrentlyMaxSpan Out of range [1, 65535]&quot;
<span class="nc" id="L721">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // pullThresholdForQueue
<span class="pc bpc" id="L726" title="2 of 4 branches missed.">        if (this.defaultMQPushConsumer.getPullThresholdForQueue() &lt; 1 || this.defaultMQPushConsumer.getPullThresholdForQueue() &gt; 65535) {</span>
<span class="nc" id="L727">            throw new MQClientException(</span>
                &quot;pullThresholdForQueue Out of range [1, 65535]&quot;
<span class="nc" id="L729">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // pullInterval
<span class="pc bpc" id="L734" title="2 of 4 branches missed.">        if (this.defaultMQPushConsumer.getPullInterval() &lt; 0 || this.defaultMQPushConsumer.getPullInterval() &gt; 65535) {</span>
<span class="nc" id="L735">            throw new MQClientException(</span>
                &quot;pullInterval Out of range [0, 65535]&quot;
<span class="nc" id="L737">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // consumeMessageBatchMaxSize
<span class="pc bpc" id="L742" title="1 of 2 branches missed.">        if (this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize() &lt; 1</span>
<span class="pc bpc" id="L743" title="1 of 2 branches missed.">            || this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize() &gt; 1024) {</span>
<span class="nc" id="L744">            throw new MQClientException(</span>
                &quot;consumeMessageBatchMaxSize Out of range [1, 1024]&quot;
<span class="nc" id="L746">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // pullBatchSize
<span class="pc bpc" id="L751" title="2 of 4 branches missed.">        if (this.defaultMQPushConsumer.getPullBatchSize() &lt; 1 || this.defaultMQPushConsumer.getPullBatchSize() &gt; 1024) {</span>
<span class="nc" id="L752">            throw new MQClientException(</span>
                &quot;pullBatchSize Out of range [1, 1024]&quot;
<span class="nc" id="L754">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }
<span class="fc" id="L757">    }</span>

    private void copySubscription() throws MQClientException {
        try {
<span class="fc" id="L761">            Map&lt;String, String&gt; sub = this.defaultMQPushConsumer.getSubscription();</span>
<span class="pc bpc" id="L762" title="1 of 2 branches missed.">            if (sub != null) {</span>
<span class="pc bpc" id="L763" title="1 of 2 branches missed.">                for (final Map.Entry&lt;String, String&gt; entry : sub.entrySet()) {</span>
<span class="nc" id="L764">                    final String topic = entry.getKey();</span>
<span class="nc" id="L765">                    final String subString = entry.getValue();</span>
<span class="nc" id="L766">                    SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(), //</span>
                        topic, subString);
<span class="nc" id="L768">                    this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span>
<span class="nc" id="L769">                }</span>
            }

<span class="pc bpc" id="L772" title="1 of 2 branches missed.">            if (null == this.messageListenerInner) {</span>
<span class="nc" id="L773">                this.messageListenerInner = this.defaultMQPushConsumer.getMessageListener();</span>
            }

<span class="pc bpc" id="L776" title="2 of 3 branches missed.">            switch (this.defaultMQPushConsumer.getMessageModel()) {</span>
                case BROADCASTING:
<span class="nc" id="L778">                    break;</span>
                case CLUSTERING:
<span class="fc" id="L780">                    final String retryTopic = MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="fc" id="L781">                    SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(), //</span>
                        retryTopic, SubscriptionData.SUB_ALL);
<span class="fc" id="L783">                    this.rebalanceImpl.getSubscriptionInner().put(retryTopic, subscriptionData);</span>
<span class="fc" id="L784">                    break;</span>
                default:
                    break;
            }
<span class="nc" id="L788">        } catch (Exception e) {</span>
<span class="nc" id="L789">            throw new MQClientException(&quot;subscription exception&quot;, e);</span>
<span class="fc" id="L790">        }</span>
<span class="fc" id="L791">    }</span>

    public MessageListener getMessageListenerInner() {
<span class="fc" id="L794">        return messageListenerInner;</span>
    }

    private void updateTopicSubscribeInfoWhenSubscriptionChanged() {
<span class="fc" id="L798">        Map&lt;String, SubscriptionData&gt; subTable = this.getSubscriptionInner();</span>
<span class="pc bpc" id="L799" title="1 of 2 branches missed.">        if (subTable != null) {</span>
<span class="fc bfc" id="L800" title="All 2 branches covered.">            for (final Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) {</span>
<span class="fc" id="L801">                final String topic = entry.getKey();</span>
<span class="fc" id="L802">                this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span>
<span class="fc" id="L803">            }</span>
        }
<span class="fc" id="L805">    }</span>

    public ConcurrentHashMap&lt;String, SubscriptionData&gt; getSubscriptionInner() {
<span class="fc" id="L808">        return this.rebalanceImpl.getSubscriptionInner();</span>
    }

    public void subscribe(String topic, String subExpression) throws MQClientException {
        try {
<span class="fc" id="L813">            SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(), //</span>
                topic, subExpression);
<span class="fc" id="L815">            this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span>
<span class="pc bpc" id="L816" title="1 of 2 branches missed.">            if (this.mQClientFactory != null) {</span>
<span class="nc" id="L817">                this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span>
            }
<span class="nc" id="L819">        } catch (Exception e) {</span>
<span class="nc" id="L820">            throw new MQClientException(&quot;subscription exception&quot;, e);</span>
<span class="fc" id="L821">        }</span>
<span class="fc" id="L822">    }</span>

    public void subscribe(String topic, String fullClassName, String filterClassSource) throws MQClientException {
        try {
<span class="nc" id="L826">            SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(), //</span>
                topic, &quot;*&quot;);
<span class="nc" id="L828">            subscriptionData.setSubString(fullClassName);</span>
<span class="nc" id="L829">            subscriptionData.setClassFilterMode(true);</span>
<span class="nc" id="L830">            subscriptionData.setFilterClassSource(filterClassSource);</span>
<span class="nc" id="L831">            this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">            if (this.mQClientFactory != null) {</span>
<span class="nc" id="L833">                this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span>
            }

<span class="nc" id="L836">        } catch (Exception e) {</span>
<span class="nc" id="L837">            throw new MQClientException(&quot;subscription exception&quot;, e);</span>
<span class="nc" id="L838">        }</span>
<span class="nc" id="L839">    }</span>

    public void suspend() {
<span class="nc" id="L842">        this.pause = true;</span>
<span class="nc" id="L843">        log.info(&quot;suspend this consumer, {}&quot;, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L844">    }</span>

    public void unsubscribe(String topic) {
<span class="nc" id="L847">        this.rebalanceImpl.getSubscriptionInner().remove(topic);</span>
<span class="nc" id="L848">    }</span>

    public void updateConsumeOffset(MessageQueue mq, long offset) {
<span class="nc" id="L851">        this.offsetStore.updateOffset(mq, offset, false);</span>
<span class="nc" id="L852">    }</span>

    public void updateCorePoolSize(int corePoolSize) {
<span class="nc" id="L855">        this.consumeMessageService.updateCorePoolSize(corePoolSize);</span>
<span class="nc" id="L856">    }</span>

    public MessageExt viewMessage(String msgId) throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
<span class="nc" id="L859">        return this.mQClientFactory.getMQAdminImpl().viewMessage(msgId);</span>
    }

    public RebalanceImpl getRebalanceImpl() {
<span class="fc" id="L863">        return rebalanceImpl;</span>
    }

    public boolean isConsumeOrderly() {
<span class="fc" id="L867">        return consumeOrderly;</span>
    }

    public void setConsumeOrderly(boolean consumeOrderly) {
<span class="fc" id="L871">        this.consumeOrderly = consumeOrderly;</span>
<span class="fc" id="L872">    }</span>

    public void resetOffsetByTimeStamp(long timeStamp)
        throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
<span class="nc bnc" id="L876" title="All 2 branches missed.">        for (String topic : rebalanceImpl.getSubscriptionInner().keySet()) {</span>
<span class="nc" id="L877">            Set&lt;MessageQueue&gt; mqs = rebalanceImpl.getTopicSubscribeInfoTable().get(topic);</span>
<span class="nc" id="L878">            Map&lt;MessageQueue, Long&gt; offsetTable = new HashMap&lt;MessageQueue, Long&gt;();</span>
<span class="nc bnc" id="L879" title="All 2 branches missed.">            if (mqs != null) {</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">                for (MessageQueue mq : mqs) {</span>
<span class="nc" id="L881">                    long offset = searchOffset(mq, timeStamp);</span>
<span class="nc" id="L882">                    offsetTable.put(mq, offset);</span>
<span class="nc" id="L883">                }</span>
<span class="nc" id="L884">                this.mQClientFactory.resetOffset(topic, groupName(), offsetTable);</span>
            }
<span class="nc" id="L886">        }</span>
<span class="nc" id="L887">    }</span>

    public long searchOffset(MessageQueue mq, long timestamp) throws MQClientException {
<span class="nc" id="L890">        return this.mQClientFactory.getMQAdminImpl().searchOffset(mq, timestamp);</span>
    }

    @Override
    public String groupName() {
<span class="fc" id="L895">        return this.defaultMQPushConsumer.getConsumerGroup();</span>
    }

    @Override
    public MessageModel messageModel() {
<span class="fc" id="L900">        return this.defaultMQPushConsumer.getMessageModel();</span>
    }

    @Override
    public ConsumeType consumeType() {
<span class="fc" id="L905">        return ConsumeType.CONSUME_PASSIVELY;</span>
    }

    @Override
    public ConsumeFromWhere consumeFromWhere() {
<span class="fc" id="L910">        return this.defaultMQPushConsumer.getConsumeFromWhere();</span>
    }

    @Override
    public Set&lt;SubscriptionData&gt; subscriptions() {
<span class="fc" id="L915">        Set&lt;SubscriptionData&gt; subSet = new HashSet&lt;SubscriptionData&gt;();</span>

<span class="fc" id="L917">        subSet.addAll(this.rebalanceImpl.getSubscriptionInner().values());</span>

<span class="fc" id="L919">        return subSet;</span>
    }

    @Override
    public void doRebalance() {
<span class="pc bpc" id="L924" title="1 of 2 branches missed.">        if (!this.pause) {</span>
<span class="fc" id="L925">            this.rebalanceImpl.doRebalance(this.isConsumeOrderly());</span>
        }
<span class="fc" id="L927">    }</span>

    @Override
    public void persistConsumerOffset() {
        try {
<span class="fc" id="L932">            this.makeSureStateOK();</span>
<span class="fc" id="L933">            Set&lt;MessageQueue&gt; mqs = new HashSet&lt;MessageQueue&gt;();</span>
<span class="fc" id="L934">            Set&lt;MessageQueue&gt; allocateMq = this.rebalanceImpl.getProcessQueueTable().keySet();</span>
<span class="fc" id="L935">            mqs.addAll(allocateMq);</span>

<span class="fc" id="L937">            this.offsetStore.persistAll(mqs);</span>
<span class="nc" id="L938">        } catch (Exception e) {</span>
<span class="nc" id="L939">            log.error(&quot;group: &quot; + this.defaultMQPushConsumer.getConsumerGroup() + &quot; persistConsumerOffset exception&quot;, e);</span>
<span class="fc" id="L940">        }</span>
<span class="fc" id="L941">    }</span>

    @Override
    public void updateTopicSubscribeInfo(String topic, Set&lt;MessageQueue&gt; info) {
<span class="fc" id="L945">        Map&lt;String, SubscriptionData&gt; subTable = this.getSubscriptionInner();</span>
<span class="pc bpc" id="L946" title="1 of 2 branches missed.">        if (subTable != null) {</span>
<span class="pc bpc" id="L947" title="1 of 2 branches missed.">            if (subTable.containsKey(topic)) {</span>
<span class="fc" id="L948">                this.rebalanceImpl.topicSubscribeInfoTable.put(topic, info);</span>
            }
        }
<span class="fc" id="L951">    }</span>

    @Override
    public boolean isSubscribeTopicNeedUpdate(String topic) {
<span class="nc" id="L955">        Map&lt;String, SubscriptionData&gt; subTable = this.getSubscriptionInner();</span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">        if (subTable != null) {</span>
<span class="nc bnc" id="L957" title="All 2 branches missed.">            if (subTable.containsKey(topic)) {</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">                return !this.rebalanceImpl.topicSubscribeInfoTable.containsKey(topic);</span>
            }
        }

<span class="nc" id="L962">        return false;</span>
    }

    @Override
    public boolean isUnitMode() {
<span class="fc" id="L967">        return this.defaultMQPushConsumer.isUnitMode();</span>
    }

    @Override
    public ConsumerRunningInfo consumerRunningInfo() {
<span class="nc" id="L972">        ConsumerRunningInfo info = new ConsumerRunningInfo();</span>

<span class="nc" id="L974">        Properties prop = MixAll.object2Properties(this.defaultMQPushConsumer);</span>

<span class="nc" id="L976">        prop.put(ConsumerRunningInfo.PROP_CONSUME_ORDERLY, String.valueOf(this.consumeOrderly));</span>
<span class="nc" id="L977">        prop.put(ConsumerRunningInfo.PROP_THREADPOOL_CORE_SIZE, String.valueOf(this.consumeMessageService.getCorePoolSize()));</span>
<span class="nc" id="L978">        prop.put(ConsumerRunningInfo.PROP_CONSUMER_START_TIMESTAMP, String.valueOf(this.consumerStartTimestamp));</span>

<span class="nc" id="L980">        info.setProperties(prop);</span>

<span class="nc" id="L982">        Set&lt;SubscriptionData&gt; subSet = this.subscriptions();</span>
<span class="nc" id="L983">        info.getSubscriptionSet().addAll(subSet);</span>

<span class="nc" id="L985">        Iterator&lt;Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it = this.rebalanceImpl.getProcessQueueTable().entrySet().iterator();</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L987">            Entry&lt;MessageQueue, ProcessQueue&gt; next = it.next();</span>
<span class="nc" id="L988">            MessageQueue mq = next.getKey();</span>
<span class="nc" id="L989">            ProcessQueue pq = next.getValue();</span>

<span class="nc" id="L991">            ProcessQueueInfo pqinfo = new ProcessQueueInfo();</span>
<span class="nc" id="L992">            pqinfo.setCommitOffset(this.offsetStore.readOffset(mq, ReadOffsetType.MEMORY_FIRST_THEN_STORE));</span>
<span class="nc" id="L993">            pq.fillProcessQueueInfo(pqinfo);</span>
<span class="nc" id="L994">            info.getMqTable().put(mq, pqinfo);</span>
<span class="nc" id="L995">        }</span>

<span class="nc bnc" id="L997" title="All 2 branches missed.">        for (SubscriptionData sd : subSet) {</span>
<span class="nc" id="L998">            ConsumeStatus consumeStatus = this.mQClientFactory.getConsumerStatsManager().consumeStatus(this.groupName(), sd.getTopic());</span>
<span class="nc" id="L999">            info.getStatusTable().put(sd.getTopic(), consumeStatus);</span>
<span class="nc" id="L1000">        }</span>

<span class="nc" id="L1002">        return info;</span>
    }

    public MQClientInstance getmQClientFactory() {
<span class="fc" id="L1006">        return mQClientFactory;</span>
    }

    public void setmQClientFactory(MQClientInstance mQClientFactory) {
<span class="nc" id="L1010">        this.mQClientFactory = mQClientFactory;</span>
<span class="nc" id="L1011">    }</span>

    public ServiceState getServiceState() {
<span class="nc" id="L1014">        return serviceState;</span>
    }

    public void setServiceState(ServiceState serviceState) {
<span class="nc" id="L1018">        this.serviceState = serviceState;</span>
<span class="nc" id="L1019">    }</span>

    public void adjustThreadPool() {
<span class="nc" id="L1022">        long computeAccTotal = this.computeAccumulationTotal();</span>
<span class="nc" id="L1023">        long adjustThreadPoolNumsThreshold = this.defaultMQPushConsumer.getAdjustThreadPoolNumsThreshold();</span>

<span class="nc" id="L1025">        long incThreshold = (long) (adjustThreadPoolNumsThreshold * 1.0);</span>

<span class="nc" id="L1027">        long decThreshold = (long) (adjustThreadPoolNumsThreshold * 0.8);</span>

<span class="nc bnc" id="L1029" title="All 2 branches missed.">        if (computeAccTotal &gt;= incThreshold) {</span>
<span class="nc" id="L1030">            this.consumeMessageService.incCorePoolSize();</span>
        }

<span class="nc bnc" id="L1033" title="All 2 branches missed.">        if (computeAccTotal &lt; decThreshold) {</span>
<span class="nc" id="L1034">            this.consumeMessageService.decCorePoolSize();</span>
        }
<span class="nc" id="L1036">    }</span>

    private long computeAccumulationTotal() {
<span class="nc" id="L1039">        long msgAccTotal = 0;</span>
<span class="nc" id="L1040">        ConcurrentHashMap&lt;MessageQueue, ProcessQueue&gt; processQueueTable = this.rebalanceImpl.getProcessQueueTable();</span>
<span class="nc" id="L1041">        Iterator&lt;Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it = processQueueTable.entrySet().iterator();</span>
<span class="nc bnc" id="L1042" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L1043">            Entry&lt;MessageQueue, ProcessQueue&gt; next = it.next();</span>
<span class="nc" id="L1044">            ProcessQueue value = next.getValue();</span>
<span class="nc" id="L1045">            msgAccTotal += value.getMsgAccCnt();</span>
<span class="nc" id="L1046">        }</span>

<span class="nc" id="L1048">        return msgAccTotal;</span>
    }

    public List&lt;QueueTimeSpan&gt; queryConsumeTimeSpan(final String topic)
        throws RemotingException, MQClientException, InterruptedException, MQBrokerException {
<span class="nc" id="L1053">        List&lt;QueueTimeSpan&gt; queueTimeSpan = new ArrayList&lt;QueueTimeSpan&gt;();</span>
<span class="nc" id="L1054">        TopicRouteData routeData = this.mQClientFactory.getMQClientAPIImpl().getTopicRouteInfoFromNameServer(topic, 3000);</span>
<span class="nc bnc" id="L1055" title="All 2 branches missed.">        for (BrokerData brokerData : routeData.getBrokerDatas()) {</span>
<span class="nc" id="L1056">            String addr = brokerData.selectBrokerAddr();</span>
<span class="nc" id="L1057">            queueTimeSpan.addAll(this.mQClientFactory.getMQClientAPIImpl().queryConsumeTimeSpan(addr, topic, groupName(), 3000));</span>
<span class="nc" id="L1058">        }</span>

<span class="nc" id="L1060">        return queueTimeSpan;</span>
    }

    public ConsumeMessageService getConsumeMessageService() {
<span class="nc" id="L1064">        return consumeMessageService;</span>
    }

    public void setConsumeMessageService(ConsumeMessageService consumeMessageService) {
<span class="fc" id="L1068">        this.consumeMessageService = consumeMessageService;</span>

<span class="fc" id="L1070">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>